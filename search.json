[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "This is a Quarto website. Work in Progress."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "spa-dev: an obvious work-in-progress"
  },
  {
    "objectID": "dsaposts/two-sum-integer/index.html",
    "href": "dsaposts/two-sum-integer/index.html",
    "title": "LeetCode 1: Two Integer Sum",
    "section": "",
    "text": "Difficulty: Easy\nGiven an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\nAssume that every input has exactly one pair of indices i and j that satisfy the condition.\nReturn the answer with the smaller index first.\nExample:\nInput: \nnums = [3,4,5,6], target = 7\nOutput: [0,1]\n# Explanation: nums[0] + nums[1] == 7, so we return [0, 1].\nAdditional examples are provided in the tests below."
  },
  {
    "objectID": "dsaposts/two-sum-integer/index.html#problem-description",
    "href": "dsaposts/two-sum-integer/index.html#problem-description",
    "title": "LeetCode 1: Two Integer Sum",
    "section": "",
    "text": "Difficulty: Easy\nGiven an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\nAssume that every input has exactly one pair of indices i and j that satisfy the condition.\nReturn the answer with the smaller index first.\nExample:\nInput: \nnums = [3,4,5,6], target = 7\nOutput: [0,1]\n# Explanation: nums[0] + nums[1] == 7, so we return [0, 1].\nAdditional examples are provided in the tests below."
  },
  {
    "objectID": "dsaposts/two-sum-integer/index.html#initial-solution",
    "href": "dsaposts/two-sum-integer/index.html#initial-solution",
    "title": "LeetCode 1: Two Integer Sum",
    "section": "Initial Solution",
    "text": "Initial Solution\n\nfrom typing import List, Callable\n\n\nclass InitialSolution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        for i, i_num in enumerate(nums):\n            for j, j_num in enumerate(nums[1:]): \n                if i_num + j_num == target and i != j+1: # must 'and' to ensure i != j \n                    return [i,j+1]\n        return [] # not really needed as we are told a solution exists\n\nNote: I first tried to ensure i != j by starting the for j loop at [1:] instead of 0. This failed the following case, which led me to add the and operator in the equality check, at which point it was apparent the slicing was unnecessary. Careful reading of the question indicates that the indices are not allowed to be equal, but there is no restriction on the numbers being equal.\nnums = [2,5,5,11]\ntarget = 10\noutput = [1,2]\nLetâ€™s clean up the function:\n\nclass BruteForceSolution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        for i, i_num in enumerate(nums):\n            for j, j_num in enumerate(nums): \n                if i_num + j_num == target and i != j:\n                    return [i,j]\n        return []\n\n\n# Examples for testing purposes.\n#nums, target = [3,4,5,6], 7 # output [0,1]\n#nums, target = [4,5,6], 10 # output [0,2]\n#nums, target = [3,3], 6 # output [0,1] \n#nums, target = [3,2,4], 6 # output [1,2]\nnums, target = [2,5,5,11], 10 # output [1,2] # tricky\n\n#solution = InitialSolution()\nsolution = BruteForceSolution()\nsolution.twoSum(nums, target)\n\n[1, 2]\n\n\nInitial Results:\nBruteForceSolution passes NeetCode submission.\n\nTime Complexity: O(n)*O(n) = O(n2)"
  },
  {
    "objectID": "dsaposts/two-sum-integer/index.html#tests",
    "href": "dsaposts/two-sum-integer/index.html#tests",
    "title": "LeetCode 1: Two Integer Sum",
    "section": "Tests",
    "text": "Tests\n\ndef test(fn: Callable[[List[int], int], List[int]]) -&gt; None:\n    nums, target = [3, 4, 5, 6], 7\n    output = [0, 1]\n    assert output == fn(nums, target)\n    \n    nums, target = [4, 5, 6], 10\n    output = [0, 2]\n    assert output == fn(nums, target)\n    \n    nums, target = [3, 3], 6\n    output = [0, 1]\n    assert output == fn(nums, target)\n    \n    nums, target = [3, 2, 4], 6\n    output = [1, 2]\n    assert output == fn(nums, target)\n    \n    nums, target = [2, 5, 5, 11], 10\n    output = [1, 2]\n    assert output == fn(nums, target)\n    print('Tests Passed')\n\n\nsolution = BruteForceSolution()\ntest(solution.twoSum)\n\nTests Passed"
  },
  {
    "objectID": "dsaposts/contains-duplicate/index.html",
    "href": "dsaposts/contains-duplicate/index.html",
    "title": "LeetCode 217: Contains Duplicate",
    "section": "",
    "text": "Difficulty: Easy\nGiven an integer array nums, return True if any value appears more than once in the array, otherwise return False.\nExample 1:\nInput: nums = [1, 2, 3, 3]\nOutput: True\nExample 2:\nInput: nums = [1, 2, 3, 4]\nOutput: False"
  },
  {
    "objectID": "dsaposts/contains-duplicate/index.html#problem-description",
    "href": "dsaposts/contains-duplicate/index.html#problem-description",
    "title": "LeetCode 217: Contains Duplicate",
    "section": "",
    "text": "Difficulty: Easy\nGiven an integer array nums, return True if any value appears more than once in the array, otherwise return False.\nExample 1:\nInput: nums = [1, 2, 3, 3]\nOutput: True\nExample 2:\nInput: nums = [1, 2, 3, 4]\nOutput: False"
  },
  {
    "objectID": "dsaposts/contains-duplicate/index.html#initial-solution",
    "href": "dsaposts/contains-duplicate/index.html#initial-solution",
    "title": "LeetCode 217: Contains Duplicate",
    "section": "Initial Solution",
    "text": "Initial Solution\nThis was really quite easy, using the Python set() function to create a set of unique numbers. We just need to ensure it returns True if the amount (length) of numbers in the set is different to that of the original list. Hence, the not operator is used below. Alternatively, replace == with != for the same result.\nNote that set() will not retain the order of the list, so we must compare its overall length and not try to compare the content one-by-one (or convert it to a list and see if the two lists match exactly).\n\nfrom typing import List\n\n\nclass InitialSolution:\n    def hasDuplicate(self, nums: List[int]) -&gt; bool:\n        return not len(set(nums)) == len(nums)\n\n\nnums1 = [1, 2, 3, 3]\nnums2 = [1, 2, 3, 4]\n\n\nsolution = InitialSolution()\nprint(solution.hasDuplicate(nums1))\nprint(solution.hasDuplicate(nums2))\n\nTrue\nFalse\n\n\nInitial Results:\nSuccess. This solution passes the full suite of tests on NeetCode."
  },
  {
    "objectID": "dsaposts/contains-duplicate/index.html#neetcode-solution",
    "href": "dsaposts/contains-duplicate/index.html#neetcode-solution",
    "title": "LeetCode 217: Contains Duplicate",
    "section": "NeetCode Solution",
    "text": "NeetCode Solution\nThe following code makes it clear that we are using a hashset to store the values. It does not create the entire set all at once (like we do above, always giving O(n) time complexity as it runs through the whole list). Instead, it goes step by step, thus only in the worst case would this be O(n). We must create the hashset, which in the worst case uses O(n) space.\n\nclass Solution:\n    def hasDuplicate(self, nums: List[int]) -&gt; bool:\n        hashset = set()\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False\n\n\nsolution = Solution()\nprint(solution.hasDuplicate(nums1))\nprint(solution.hasDuplicate(nums2))\n\nTrue\nFalse\n\n\nConclusion:\nAn easy start to NeetCode problems. The solution has a worst-case complexity of:\n\nTime complexity: O(n)\nSpace complexity: O(n)"
  },
  {
    "objectID": "dsaposts/welcome/index.html",
    "href": "dsaposts/welcome/index.html",
    "title": "Welcome To Data Structures & Algorithms",
    "section": "",
    "text": "Welcome! This is intended to be a repository of my solutions to LeetCode problems."
  },
  {
    "objectID": "dsa.html",
    "href": "dsa.html",
    "title": "LeetCode",
    "section": "",
    "text": "Data Structures & Algorithms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeetCode 217: Contains Duplicate\n\n\n\n\n\n\ncode\n\n\narrays and hashing\n\n\neasy\n\n\n\n\n\n\n\n\n\nMay 28, 2024\n\n\nspa-dev\n\n\n\n\n\n\n\n\n\n\n\n\nLeetCode 1: Two Integer Sum\n\n\n\n\n\n\ncode\n\n\narrays and hashing\n\n\neasy\n\n\n\n\n\n\n\n\n\nMay 27, 2024\n\n\nspa-dev\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To Data Structures & Algorithms\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nMay 26, 2024\n\n\nspa-dev\n\n\n\n\n\n\nNo matching items"
  }
]